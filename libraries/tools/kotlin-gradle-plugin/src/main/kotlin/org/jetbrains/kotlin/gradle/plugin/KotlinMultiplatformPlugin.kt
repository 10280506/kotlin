/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.gradle.plugin

import com.android.build.gradle.BaseExtension
import org.gradle.api.GradleException
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ProjectDependency
import org.gradle.api.file.SourceDirectorySet
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.SourceSetContainer
import org.jetbrains.kotlin.gradle.tasks.AbstractKotlinCompile

abstract class KotlinPlatformPluginBase(protected val platformName: String) : Plugin<Project> {
    companion object {
        @JvmStatic
        protected inline fun <reified T : Plugin<*>> Project.applyPlugin() {
            pluginManager.apply(T::class.java)
        }
    }
}

open class KotlinPlatformCommonPlugin : KotlinPlatformPluginBase("common") {
    override fun apply(project: Project) {
        project.applyPlugin<KotlinCommonPluginWrapper>()
    }
}

const val EXPECTED_BY_CONFIG_NAME = "expectedBy"

const val IMPLEMENT_CONFIG_NAME = "implement"
const val IMPLEMENT_DEPRECATION_WARNING = "The '$IMPLEMENT_CONFIG_NAME' configuration is deprecated and will be removed. " +
                                          "Use '$EXPECTED_BY_CONFIG_NAME' instead."

open class KotlinPlatformImplementationPluginBase(platformName: String) : KotlinPlatformPluginBase(platformName) {
    private val commonProjects = arrayListOf<Project>()
    private val platformKotlinTasksBySourceSetName = hashMapOf<String, AbstractKotlinCompile<*>>()

    override fun apply(project: Project) {
        project.tasks.filterIsInstance<AbstractKotlinCompile<*>>().associateByTo(platformKotlinTasksBySourceSetName) { it.sourceSetName }

        val implementConfig = project.configurations.create(IMPLEMENT_CONFIG_NAME)
        val expectedByConfig = project.configurations.create(EXPECTED_BY_CONFIG_NAME)

        implementConfig.dependencies.whenObjectAdded {
            if (!implementConfigurationIsUsed) {
                implementConfigurationIsUsed = true
                project.logger.kotlinWarn(IMPLEMENT_DEPRECATION_WARNING)
            }
        }

        listOf(implementConfig, expectedByConfig).forEach { config ->
            config.isTransitive = false

            config.dependencies.whenObjectAdded { dep ->
                if (dep is ProjectDependency) {
                    addCommonProject(dep.dependencyProject, project)

                    // Needed for the projects that depend on this one to recover the common module sources through
                    // the transitive dependency (also, it will be added to the POM generated by Gradle):
                    project.configurations.getByName("compile").dependencies.add(dep)
                }
                else {
                    throw GradleException("$project '${config.name}' dependency is not a project: $dep")
                }
            }
        }

        val incrementalMultiplatform = PropertiesProvider(project).incrementalMultiplatform ?: true
        project.afterEvaluate {
            project.tasks.withType(AbstractKotlinCompile::class.java).all {
                if (it.incremental && !incrementalMultiplatform) {
                    project.logger.debug("IC is turned off for task '${it.path}' because multiplatform IC is not enabled")
                }
                it.incremental = it.incremental && incrementalMultiplatform
            }
        }

        project.afterEvaluate {
            // Workaround: with configure-on-demand, we still need to evaluate all projects. This forces them to evaluate:
            project.rootProject.allprojects { project ->
                project.rootProject.evaluationDependsOn(project.path)
            }

            val mainSourceSet = project.sourceSets.getByName("main")
            val configurationToAddDeps = project.configurations.getByName("implementation")
            val configurationToCheckDeps =
                mainSourceSet.compileClasspath as? Configuration
                        ?: project.configurations.findByName(mainSourceSet.compileClasspathConfigurationName)
                        ?: configurationToAddDeps

            setUpPlatformModuleDependencies(
                project,
                configurationToCheck = configurationToCheckDeps,
                configurationToModify = configurationToAddDeps
            )
        }
    }

    private var implementConfigurationIsUsed = false

    private fun platformImplementationConfigName(platform: String) = "platform${platform.capitalize()}Implementations"

    private fun addCommonProject(commonProject: Project, platformProject: Project) {
        commonProjects.add(commonProject)

        commonProject.whenEvaluated {
            if (!commonProject.pluginManager.hasPlugin("kotlin-platform-common")) {
                throw GradleException(
                        "Platform project $platformProject has an " +
                        "'$EXPECTED_BY_CONFIG_NAME'${if (implementConfigurationIsUsed) "/'$IMPLEMENT_CONFIG_NAME'" else ""} " +
                        "dependency to non-common project $commonProject")
            }

            commonProject.sourceSets.all { commonSourceSet ->
                // todo: warn if not found
                addCommonSourceSetToPlatformSourceSet(commonSourceSet, platformProject)
            }

            val platformImplementationConfigName = platformImplementationConfigName(platformName)
            commonProject.configurations.maybeCreate(platformImplementationConfigName)
            commonProject.dependencies.add(platformImplementationConfigName, platformProject)
        }
    }

    private fun getProjectDependencies(from: Project, fromConfiguration: String): List<Project> {

        data class ProjectConfiguration(val project: Project, val configuration: String)

        fun collectDependenciesFrom(project: Project, configuration: String) =
            project.configurations.findByName(configuration)?.allDependencies
                .orEmpty()
                .filterIsInstance<ProjectDependency>()
                .map { ProjectConfiguration(it.dependencyProject, it.targetConfiguration ?: "default") }

        val bfsSequence = generateSequence(listOf(ProjectConfiguration(from, fromConfiguration))) { prev ->
            prev.flatMap { (project, conf) -> collectDependenciesFrom(project, conf) }
                .takeIf { it.isNotEmpty() }
        }

        return bfsSequence
            .drop(1)
            .flatten()
            .map { it.project }
            .distinct()
            .toList()
    }

    //TODO adapt for Native
    private val platformDisplayName = platformName.toUpperCase()

    private fun setUpPlatformModuleDependencies(
        project: Project,
        configurationToCheck: Configuration,
        configurationToModify: Configuration
    ) {
        // Run the checks when the dependencies are resolved in the configuration that we'd like to add the dependencies to:
        configurationToModify.withDependencies {
            val expectedByProjectDeps =
                project.configurations.getByName(EXPECTED_BY_CONFIG_NAME).allDependencies
                    .filterIsInstance<ProjectDependency>()

            val transitiveCommonDeps: List<Project> =
                expectedByProjectDeps
                    .flatMap { dep -> getProjectDependencies(dep.dependencyProject, dep.targetConfiguration ?: "default") }
                    .distinct()

            val projectDependencies =
                getProjectDependencies(project, configurationToCheck.name)

            transitiveCommonDeps.forEach { commonModule ->
                val existingPlatformModulesForCommon =
                    commonModule.configurations
                        .findByName(platformImplementationConfigName(platformName))?.dependencies.orEmpty()
                        .filterIsInstance<ProjectDependency>().map { it.dependencyProject }

                val thisProjectDependsOnPlatformImpls = projectDependencies.filter { it in existingPlatformModulesForCommon }

                // When the project depends on a platform module for commonModule, check that the commonModule is not in expectedBy:
                if (thisProjectDependsOnPlatformImpls.isNotEmpty() &&
                    expectedByProjectDeps.any { it.dependencyProject == commonModule }
                ) {
                    project.logger.kotlinWarn(
                        "The platform module ${project.path} is expected by a common module ${commonModule.path} and at the same time " +
                                "depends on its platform implementation (${thisProjectDependsOnPlatformImpls.joinToString { it.path }}). " +
                                "Please make sure there is either an expectedBy dependency OR a platform dependency, not both.\n")
                }

                when {
                    thisProjectDependsOnPlatformImpls.size == 1 -> Unit

                    thisProjectDependsOnPlatformImpls.size > 1 -> {
                        project.logger.kotlinWarn(
                            "The platform module ${project.path} depends on more than one ${platformDisplayName} " +
                                    "platform module for ${commonModule.path}: \n" +
                                    thisProjectDependsOnPlatformImpls.joinToString("\n") { " * ${it.path}" } +
                                    "\nTo avoid undefined behavior at runtime, please make sure there is a dependency on only one of them.\n")
                    }

                    // Otherwise this project does not have a dependency on a platform implementation for commonModule:

                    existingPlatformModulesForCommon.isEmpty() -> {
                        project.logger.kotlinWarn(
                            "No $platformDisplayName platform module found for the common dependency ${commonModule.path} of " +
                                    "platform module ${project.path}. Please make sure there is a ${platformDisplayName} " +
                                    "platform implementation and " +
                                    "the project containing it is evaluated at the moment of the dependency resolution.\n"
                        )
                    }

                    existingPlatformModulesForCommon.size == 1 -> {
                        val singlePlatformImpl = existingPlatformModulesForCommon.single()
                        project.logger.kotlinInfo(
                            "Found a single ${platformDisplayName} platform implementation ${singlePlatformImpl.path} " +
                                    "for the common dependency ${commonModule.path}. " +
                                    "Adding it to ${configurationToModify}.\n"
                        )
                        project.dependencies.add(configurationToModify.name, singlePlatformImpl)
                    }

                    else -> { // existingPlatformModulesForCommon.size > 1
                        project.logger.kotlinWarn(
                            "A platform module ${project.path} does not explicitly depend on a ${platformDisplayName} platform implementation " +
                                    "of its common dependency ${commonModule.path}. " +
                                    "Please manually choose one of the platform modules and add it as a dependency:\n" +
                                    existingPlatformModulesForCommon.joinToString("\n") { " * ${it.path}" } + "\n"
                        )
                    }
                }
            }
        }
    }

    protected open fun addCommonSourceSetToPlatformSourceSet(commonSourceSet: SourceSet, platformProject: Project) {
        val platformTask = platformKotlinTasksBySourceSetName[commonSourceSet.name]
        commonSourceSet.kotlin!!.srcDirs.forEach { platformTask?.source(it) }
    }

    protected val SourceSet.kotlin: SourceDirectorySet?
        get() {
            // Access through reflection, because another project's KotlinSourceSet might be loaded
            // by a different class loader:
            val convention = (getConvention("kotlin") ?: getConvention("kotlin2js")) ?: return null
            val kotlinSourceSetIface = convention.javaClass.interfaces.find { it.name == KotlinSourceSet::class.qualifiedName }
            val getKotlin = kotlinSourceSetIface?.methods?.find { it.name == "getKotlin" } ?: return null
            return getKotlin(convention) as? SourceDirectorySet
        }

    companion object {
        @JvmStatic
        protected fun <T> Project.whenEvaluated(fn: Project.() -> T) {
            if (state.executed) {
                fn()
            }
            else {
                afterEvaluate { it.fn() }
            }
        }
    }
}

open class KotlinPlatformAndroidPlugin : KotlinPlatformImplementationPluginBase("android") {
    override fun apply(project: Project) {
        project.applyPlugin<KotlinAndroidPluginWrapper>()
        super.apply(project)
    }

    override fun addCommonSourceSetToPlatformSourceSet(commonSourceSet: SourceSet, platformProject: Project) {
        val androidExtension = platformProject.extensions.getByName("android") as BaseExtension
        val androidSourceSet = androidExtension.sourceSets.findByName(commonSourceSet.name) ?: return
        val kotlinSourceSet = androidSourceSet.getConvention(KOTLIN_DSL_NAME) as? KotlinSourceSet ?: return
        kotlinSourceSet.kotlin.source(commonSourceSet.kotlin!!)
    }
}

open class KotlinPlatformJvmPlugin : KotlinPlatformImplementationPluginBase("jvm") {
    override fun apply(project: Project) {
        project.applyPlugin<KotlinPluginWrapper>()
        super.apply(project)
    }
}

open class KotlinPlatformJsPlugin : KotlinPlatformImplementationPluginBase("js") {
    override fun apply(project: Project) {
        project.applyPlugin<Kotlin2JsPluginWrapper>()
        super.apply(project)
    }
}

private val Project.sourceSets: SourceSetContainer
    get() = convention.getPlugin(JavaPluginConvention::class.java).sourceSets
